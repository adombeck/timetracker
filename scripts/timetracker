#!/usr/bin/env python3

import logging
import sys
import signal
import subprocess
import tempfile

import gi
gi.require_version('Gtk', '3.0')
gi.require_version('Notify', '0.7')
from gi.repository import Gtk, Gio, GLib, Notify

from timetracker import DATA_DIR, TASK_DIR
from timetracker.task import Task
from timetracker.timer import Timer
from timetracker.screenlock_monitor import ScreenlockMonitor
from timetracker.task_dialog import DialogCancelledError, run_task_dialog

logger = logging.getLogger(__name__)


class App(Gtk.Application):
    def __init__(self):
        logger.debug("in App.__init__")
        super().__init__(application_id="foo.timetracker")

        self.timer = Timer()
        self.screenlock_monitor = ScreenlockMonitor(self)

        self.notification = None  # type: Notify.Notification

        self.add_main_option("verbose", 0, 0, 0, "Print debug messages")
        self.add_main_option("new", 0, 0, 0, "Create a new task")
        self.add_main_option("start", 0, 0, 0, "Start clocking")
        self.add_main_option("stop", 0, 0, 0, "Stop clocking")
        self.add_main_option("toggle", 0, 0, 0, "Toggle clocking")
        self.add_main_option("print-timesheet", 0, 0, 0, "Print a timesheet listing the time spent in total on each task (in HH:MM format)")
        self.add_main_option("quit", 0, 0, 0, "Quit the application")
        self.connect("handle-local-options", self.do_handle_local_options)

        action = Gio.SimpleAction.new("new", parameter_type=None)
        action.connect("activate", self.handle_new)
        self.add_action(action)

        action = Gio.SimpleAction.new("start", parameter_type=None)
        action.connect("activate", self.handle_start)
        self.add_action(action)

        action = Gio.SimpleAction.new("stop", parameter_type=None)
        action.connect("activate", self.handle_stop)
        self.add_action(action)

        action = Gio.SimpleAction.new("toggle", parameter_type=None)
        action.connect("activate", self.handle_toggle)
        self.add_action(action)

        action = Gio.SimpleAction.new("quit", parameter_type=None)
        action.connect("activate", self.handle_quit)
        self.add_action(action)

        self.register()
        if self.get_is_remote():
            return

        print("Initializing primary instance")

        Notify.init("timetracker")
        self.status_icon = Gtk.StatusIcon(visible=True)
        self.set_status_icon(running=False)
        self.menu = Gtk.Menu()

        item = Gtk.MenuItem()
        item.set_label("Open tasks directory")
        item.connect("activate", self.handle_open_tasks_directory)
        self.menu.append(item)

        item = Gtk.MenuItem()
        item.set_label("Show timesheet")
        item.connect("activate", self.handle_show_timesheet)
        self.menu.append(item)

        item = Gtk.MenuItem()
        item.set_label("Quit")
        item.connect("activate", self.handle_quit)
        self.menu.append(item)

        self.menu.show_all()
        self.status_icon.connect("popup-menu", self.show_menu)
        self.hold()

    @property
    def is_running(self) -> bool:
        return self.timer.thread and not self.timer.thread.halt.is_set()

    def do_handle_local_options(self, app: Gio.Application, options: GLib.VariantDict):
        if options.contains("verbose"):
            logging.basicConfig(level=logging.DEBUG)
        else:
            logging.basicConfig(level=logging.INFO)

        if options.contains("new"):
            self.activate_action("new")
        elif options.contains("start"):
            self.activate_action("start")
        elif options.contains("stop"):
            self.activate_action("stop")
        elif options.contains("toggle"):
            self.activate_action("toggle")
        elif options.contains("quit"):
            self.activate_action("quit")
            return 0
        elif options.contains("print-timesheet"):
            print(get_timesheet())
            return 0
        else:
            self.set_status_icon(running=False)

        return 0

    def handle_new(self, action, user_data=None):
        self.create_new_task()

    def handle_start(self, action, user_data=None):
        self.start_clocking()
        self.screenlock_monitor.start()

    def handle_stop(self, action, user_data=None):
        self.stop_clocking()
        self.screenlock_monitor.stop()

    def handle_toggle(self, action, user_data=None):
        self.toggle_clocking()

    def handle_quit(self, action, user_data=None):
        logger.info("Quitting")
        self.timer.stop()
        self.quit()

    def handle_open_tasks_directory(self, event):
        subprocess.Popen(["xdg-open", TASK_DIR])

    def handle_show_timesheet(self, event):
        f = tempfile.NamedTemporaryFile(mode="w+", prefix="timesheet-", suffix=".txt", delete=False)
        f.write(get_timesheet())
        subprocess.Popen(["gedit", "-", f.name])

    def show_menu(self, icon: Gtk.StatusIcon, button: int, time: int):
        self.menu.popup(parent_menu_shell=None,
                        parent_menu_item=None,
                        func=Gtk.StatusIcon.position_menu,
                        data=icon,
                        button=button,
                        activate_time=time)

    def create_new_task(self):
        logger.info("Creating new task")

        try:
            name, additional_minutes = run_task_dialog()
        except DialogCancelledError:
            logger.info(str(DialogCancelledError))
            return

        try:
            task = Task(name)
        except Exception as e:
            logger.exception(e)
            error_dialog = Gtk.MessageDialog(parent=None,
                                             message_type=Gtk.MessageType.ERROR,
                                             text=str(e),
                                             buttons=Gtk.ButtonsType.CLOSE)
            error_dialog.run()
            error_dialog.close()
            return

        task.create()
        self.start_clocking(task, additional_minutes)

    def start_clocking(self, task: Task = None, additional_minutes: int = 0):
        logger.info("Starting clocking")
        self.timer.start(task, additional_minutes)
        self.set_status_icon(running=True)
        self.send_started_notification()

    def stop_clocking(self):
        logger.info("Stopping clocking")
        self.timer.stop()
        self.set_status_icon(running=False)
        self.send_stopped_notification()

    def toggle_clocking(self):
        logger.info("Toggling clocking")
        if self.is_running:
            self.stop_clocking()
            self.screenlock_monitor.stop()
        else:
            self.start_clocking()
            self.screenlock_monitor.start()

    def set_status_icon(self, running: bool):
        if running:
            self.status_icon.set_from_icon_name("gtk-yes")
        else:
            self.status_icon.set_from_icon_name("gtk-no")

    def send_started_notification(self):
        if self.notification:
            self.notification.close()
        self.notification = Notify.Notification.new("Clocking task '%s'" % Task.get_last().name)
        self.notification.show()

    def send_stopped_notification(self):
        if self.notification:
            self.notification.close()
        self.notification = Notify.Notification.new("Stopped clocking task '%s'" % Task.get_last().name)
        self.notification.show()


def get_timesheet() -> str:
    lines = list()
    for task in Task.get_all():
        seconds = task.get_sum()
        minutes, seconds = divmod(seconds, 60)
        hours, minutes = divmod(minutes, 60)
        lines.append("%s: %i:%.2i" % (task.name, hours, minutes))
    return "\n".join(sorted(lines))


def main():
    # Workaround for https://bugzilla.gnome.org/show_bug.cgi?id=622084
    signal.signal(signal.SIGINT, signal.SIG_DFL)

    if not DATA_DIR.exists():
        DATA_DIR.mkdir(mode=0o700)

    if not TASK_DIR.exists():
        TASK_DIR.mkdir(mode=0o700)

    app = App()
    app.run(sys.argv)


if __name__ == "__main__":
    main()
